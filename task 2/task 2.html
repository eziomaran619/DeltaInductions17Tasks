<!DOCTYPE html>
<html>
<head>
	<title>RogueLike Dungeon Crawler</title>

	<style type="text/css">

		#gameCanvas {
			background-color: black ; 
			display: block ; /* to avoid scroll bars */
		}

	</style>
</head>
<body style="background-color: black ;">

	<canvas id="gameCanvas" width ="1520" height = "740" style="cursor: none;" onmousemove="setAimPosition(event)"></canvas> 

	<script type="text/javascript">  //initially draw the basic layout at 610 , 220 i.e top left corner co-ordinates
		
		'use strict'


		var level = 1 ;

		var readInstructions = document.createElement("IMG") ;
		readInstructions.src = "read instructions tip.png" ;

		var displayInstructions = false ;

		var instructions = document.createElement("IMG") ;
		instructions.src = "Instructions.png" ;

		var canvas = document.getElementById("gameCanvas") , cxt = canvas.getContext("2d") ;

		function mouseAim () {
			this.x = 100 ;
			this.y = 100 ;
			this.frameHeight = 50 ;
			this.frameWidth = 50 ;
		}

		var aim = new mouseAim() ;

		var aimImage = document.createElement("IMG") ;
		aimImage.src = "mouse_aim.png" ;




		function setAimPosition (e) {
			aim.x = e.clientX - canvas.offsetLeft ;
			aim.y = e.clientY - canvas.offsetTop ;
		}



		var dungeonTopBoundary = 320 , dungeonBottomBoundary = 1820 , dungeonLeftBoundary = 710 , dungeonRightBoundary = 3210 ; 

		//the backgrond image
		var dungeonBasicLayout = document.createElement("IMG") ;
		dungeonBasicLayout.src = "dungeon_basic_layout.png" ;

		var drawEverything = false ;

		// protagonist object constructor
		function protagonist () {
			this.x = 760 ;
			this.y = 370 ;
			this.type = "professor" ;
			this.direction = "south" ;
			this.totalAnimationFrames = 9 ; // refers to horizontal or vertical depending on the character
			this.currentHorizontalFrameIndex = 0 ;
			this.currentVerticalFrameIndexForMovement = { "south" :  2 , "north" :  0 , "east" :  3 , "west" :  1 } ;
			this.currentVerticalFrameIndex = this.currentVerticalFrameIndexForMovement[this.direction] ;
			this.frameHeight = 64 ;
			this.frameWidth = 64 ;
			this.actualHeight = 64 ;
			this.actualWidth = 30 ;
			this.speed = 5 ;
			this.collision = {south : false , north : false , east : false , west : false} ;
			this.keyPressed = {w : false , a : false , s : false , d : false} ;
			this.movementAnimationTimeInterval ;
			this.movementAnimationStarted = false ;
			this.coinRotationAnimationTimeInterval ;
			this.coinsCollected = 0 ;
			this.cutSceneAnimationTimeInterval ;
			this.cutSceneAnimationRadius = 5 ;
			this.stopRequestingFrame = false ;
			this.levelCompleted = false ;
			this.gameOver = false ;
			this.cutSceneAnimation = true ;
			this.visionRadius = 700 ; // 400 to 600 is playable , false -> full visibility

			this.footStepsSoundFile = document.createElement("AUDIO") ;
			this.footStepsSoundFile.src = "sound_files/fast_walking_foot_steps_sound_1.mp3" ;
			this.footStepsSoundFile.volume = 0.1 ;

			this.coinCollectionSoundFile = document.createElement("AUDIO") ;
			this.coinCollectionSoundFile.src = "sound_files/magic_chime_on_collecting_coin.mp3" ;
			this.coinCollectionSoundFile.volume = 0.02 ;

			this.mainBossDoorKeyCollectionSoundFile = document.createElement("AUDIO") ;
			this.mainBossDoorKeyCollectionSoundFile.src = "sound_files/magic_chime_on_collecting_the_keys.mp3" ;
			this.mainBossDoorKeyCollectionSoundFile.volume = 0.5 ;

			this.mainBossDoorKeyClueSoundFile = document.createElement("AUDIO") ;
			this.mainBossDoorKeyClueSoundFile.src = "sound_files/main_boss_door_key_sound_clue.mp3" ;

			this.mainBossDoorOpeningSoundFile = document.createElement("AUDIO") ;
			this.mainBossDoorOpeningSoundFile.src = "sound_files/azumanga_on_finishing_level.mp3" ;
			this.mainBossDoorOpeningSoundFile.volume = 0.5 ;

			this.eagleIntroSoundFile = document.createElement("AUDIO") ;
			this.eagleIntroSoundFile.src = "sound_files/eagle scream.mp3" ;
			this.eagleIntroSoundFile.volume = 0.02 ;
			
		}

		// protagonist image
		var protagonistImage = document.createElement("IMG") ;
		protagonistImage.src = "character_sprites/professor_movement_sprite.png" ;
		
		// wall with shadow image
		var wallWithShadow = document.createElement("IMG") ;
		wallWithShadow.src = "wall_with_shadow.png" ;

		// wall without shadow image
		var wallWithoutShadow = document.createElement("IMG") ;
		wallWithoutShadow.src = "wall_without_shadow.png" ;


        var coinRotationSprite = document.createElement("IMG") ;
		coinRotationSprite.src = "sprites/rotating_coin_sprite.png" ;		

		var mainBossDoorKeyImage = document.createElement("IMG") ;
		mainBossDoorKeyImage.src = "key.png" ;

		var mainBossDoorSprite = document.createElement("IMG") ;
		mainBossDoorSprite.src = "sprites/main_boss_door_sprite.png" ;

		var healthBarSprite = document.createElement("IMG") ;
		healthBarSprite.src = "sprites/health_bar_sprite.png" ;

		var numbersSprite = document.createElement("IMG") ;
		numbersSprite.src = "numbers.png" ;

		//var drawDungeonfloorTile = false ;

		//var dungeonFloorTileImage = document.createElement("IMG") ;
		//dungeonFloorTileImage.src = "dungeon_floor_tile.png" ;
		



		// pillar constructor
		function pillar(X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
			this.shadowed = true ; 
			// probability ratio of pillar to be shadowed to not shadowed is 3:1 for last row pillars and is 3:2 for other pillars
			// as the probability to be shadowed is more, it is made default
		}


        // each pillar has one and only wall
		function wall (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
			this.shadowed ; // here the probability ratio is unity, so no bias
			this.type ;
		}

        function dungeonUpperBoundaryWall (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
		}

		function coin (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.frameWidth = 40 ;
			this.frameHeight = 40 ;
			this.totalAnimationFrames = 10 ;
			this.currentFrameIndex = 0 ;
		}


		function door(X,Y) {
			this.x = X ;
			this.y = Y ;
			this.frameWidth = 237/6 ;
			this.frameHeight = 50 ;
			this.totalAnimationFrames = 6 ;
			this.currentFrameIndex = 0 ;
			this.doorOpeningAnimationTimeInterval ;
		}



		function doorKey(X,Y) {
			this.x = X ;
			this.y = Y ;
			this.collected = false ;
			this.visible = false ;
		}

		function dungeonFloorTile (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
		}

		function bar () {
			this.frameWidth = 168 ;
			this.frameHeight = 100 ;
			this.x = canvas.width - this.frameWidth ;
			this.y = 0 ;
			this.currentFrameIndex = 0 ;
			this.level = 7 ;
		}

		function countdown () {			
			this.frameWidth = 626/10 ;
			this.frameHeight = 88 ;
			this.minutes = 3 ;
			this.seconds = 30 ;
			this.timeInterval ;

			this.timeOutSoundFile = document.createElement("AUDIO") ;
			this.timeOutSoundFile.src = "sound_files/time out air horn.mp3" ;
			this.timeOutSoundFile.volume = 0.2 ;

			this.lastFewSecondsCountdownSoundFile = document.createElement("AUDIO") ;
			this.lastFewSecondsCountdownSoundFile.src = "sound_files/last few seconds countdown sound.mp3" ;
			this.lastFewSecondsCountdownSoundFile.volume = 0.03 ;

			this.countdownMinuteReminderSoundFile = document.createElement("AUDIO") ;
			this.countdownMinuteReminderSoundFile.src = "sound_files/metal gong sound.mp3" ;
			this.countdownMinuteReminderSoundFile.volume = 0.04 ;
		}

        
        var gameCountdown = undefined ;

        var healthBar = undefined ;

		var mainBossDoorKey = undefined , mainBossDoor = undefined ; 

		var dungeonPillars = undefined , dungeonPillarsCount = undefined ;

		var dungeonPillarsByDefault = undefined , dungeonPillarsByDefaultCount = undefined ;

		var dungeonNewFloorTiles = undefined , dungeonNewFloorTilesCount = undefined ;
		

		var dungeonWalls = undefined , dungeonWallsCount = undefined ;

        var dungeonUpperBoundaryWallsToBeUnshadowed = undefined , dungeonUpperBoundaryWallsToBeUnshadowedCount = undefined ;

		var coins = undefined , coinsCount = undefined ;


		// remember camera is fixed to the protagonist, so the entire surrounding moves, so is the overallDisplacement object
		var overallDisplacement = undefined , previousOverallDisplacement = undefined ;

		// our game's protagonist
		var protagonistObj = undefined ;






		dungeonBasicLayout.onload = function () { drawEverything = true ; }


		




       


		function Game() {

			this.cxt = canvas.getContext("2d") ;

			document.addEventListener("keydown" , function (e) {

				if ( (e.key == "e" || e.key == "E") && mainBossDoorKey.collected == true && 
					  mainBossDoor.currentFrameIndex == 0 && protagonistObj.type != "eagle") {

					if (protagonistObj.x>mainBossDoor.x-50+overallDisplacement.x && 
						protagonistObj.x<mainBossDoor.x+50+overallDisplacement.x &&
					    protagonistObj.y>mainBossDoor.y-25+overallDisplacement.y && 
					    protagonistObj.y<mainBossDoor.y+75+50+overallDisplacement.y) {

						protagonistObj.mainBossDoorKeyClueSoundFile.pause () ;
					    protagonistObj.mainBossDoorKeyClueSoundFile.load () ;

						level ++ ;

						clearInterval(gameCountdown.timeInterval) ;


						mainBossDoor.doorOpeningAnimationTimeInterval = setInterval(function () {

							if (mainBossDoor.currentFrameIndex == mainBossDoor.totalAnimationFrames -1 ) {

						        protagonistObj.mainBossDoorOpeningSoundFile.play() ;

						        protagonistObj.levelCompleted = true ;

								clearInterval(mainBossDoor.doorOpeningAnimationTimeInterval) ;
							    
						        } else { protagonistObj.mainBossDoorKeyClueSoundFile.pause () ; 
						        	     mainBossDoor.currentFrameIndex++ ; }

						},80) ;
					}

				}
			
			} ) ;


			document.addEventListener("keydown" , function (e) {

				if (e.key == "i" || e.key == "I") {
					displayInstructions = true ;
				}

				if (e.keyCode == 27) {
					displayInstructions = false ;
				}

               
				if ((e.key === "s" || e.key === "S") && protagonistObj.cutSceneAnimation == false) {

					protagonistObj.keyPressed.s = true ;
					protagonistObj.keyPressed.a = false ;
					protagonistObj.keyPressed.d = false ;
					protagonistObj.keyPressed.w = false ;


					
				}


                
				if ((e.key === "a" || e.key === "A") && protagonistObj.cutSceneAnimation == false) {

					protagonistObj.keyPressed.s = false ;
					protagonistObj.keyPressed.a = true ;
					protagonistObj.keyPressed.d = false ;
					protagonistObj.keyPressed.w = false ;			            


				}


                
				if ((e.key === "d" || e.key === "D") && protagonistObj.cutSceneAnimation == false) {

					protagonistObj.keyPressed.s = false ;
					protagonistObj.keyPressed.a = false ;
					protagonistObj.keyPressed.d = true ;
					protagonistObj.keyPressed.w = false ;

					
				}


                
				if ((e.key === "w" || e.key === "W") && protagonistObj.cutSceneAnimation == false) {

					protagonistObj.keyPressed.s = false ;
					protagonistObj.keyPressed.a = false ;
					protagonistObj.keyPressed.d = false ;
					protagonistObj.keyPressed.w = true ;

								    
				}

				if (e.key == "1" && protagonistObj.type != "professor") {

					overallDisplacement.x = previousOverallDisplacement.x ;
					overallDisplacement.y = previousOverallDisplacement.y ;
			        
			        	protagonistObj.type = "professor" ;
			            protagonistObj.totalAnimationFrames = 9 ; // refers to horizontal or vertical depending on the character
			            protagonistObj.currentHorizontalFrameIndex = 0 ;
			            protagonistObj.currentVerticalFrameIndexForMovement = { "south" :  2 , "north" :  0 , "east" :  3 , "west" :  1 } ;
			            protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement[protagonistObj.direction] ;
			            protagonistObj.frameHeight = 64 ;
			            protagonistObj.frameWidth = 64 ;
			            protagonistObj.actualHeight = 64 ;
			            protagonistObj.actualWidth = 30 ;
			            protagonistObj.speed = 5 ;
			            protagonistObj.visionRadius = 700 ; // false -> full visibility
			        
			            protagonistImage.src = "character_sprites/professor_movement_sprite.png" ;
			        
			            protagonistObj.footStepsSoundFile.src = "sound_files/fast_walking_foot_steps_sound_1.mp3" ;
			            protagonistObj.footStepsSoundFile.volume = 0.1 ;
			        
			
				}

				if (e.key == "2" && protagonistObj.type != "combatant") {

					overallDisplacement.x = previousOverallDisplacement.x ;
					overallDisplacement.y = previousOverallDisplacement.y ;
			        
			        	protagonistObj.type = "combatant" ;
			        	protagonistObj.totalAnimationFrames = 8 ; // refers to horizontal or vertical depending on the character
			        	protagonistObj.currentHorizontalFrameIndex = 0 ;
			        	protagonistObj.currentVerticalFrameIndexForMovement = { "south" :  0 , "north" :  3 , "east" :  2 , "west" :  1 } ;
			        	protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement[protagonistObj.direction] ;
			        	protagonistObj.frameHeight = 70 ;
			        	protagonistObj.frameWidth = 70 ;
			        	protagonistObj.actualHeight = 70 ;
			        	protagonistObj.actualWidth = 40 ;
			        	protagonistObj.speed = 5 ;
			        	protagonistObj.visionRadius = 450 ; // false -> full visibility
			        
			        	protagonistImage.src = "character_sprites/combatant_movement_sprite.png" ;
			        
			        	protagonistObj.footStepsSoundFile.src = "sound_files/fast_walking_foot_steps_sound_1.mp3" ;
			        	protagonistObj.footStepsSoundFile.volume = 0.1 ;
			        
			
				}

				if (e.key == "3" && protagonistObj.type != "escapist") {

					overallDisplacement.x = previousOverallDisplacement.x ;
					overallDisplacement.y = previousOverallDisplacement.y ;
			        
			        	protagonistObj.type = "escapist" ;
			        	protagonistObj.totalAnimationFrames = 8 ; // refers to horizontal or vertical depending on the character
			        	protagonistObj.currentHorizontalFrameIndex = 0 ;
			        	protagonistObj.currentVerticalFrameIndexForMovement = { "south" :  0 , "north" :  3 , "east" :  2 , "west" :  1 } ;
			        	protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement[protagonistObj.direction] ;
			        	protagonistObj.frameHeight = 50 ;
			        	protagonistObj.frameWidth = 50 ;
			        	protagonistObj.actualHeight = 50 ;
			        	protagonistObj.actualWidth = 50 ;
			        	protagonistObj.speed = 7 ;
			        	protagonistObj.visionRadius = 400 ; // false -> full visibility
			        
			        
			        	protagonistImage.src = "character_sprites/escapist_movement_sprite.png" ;
			        
			        	protagonistObj.footStepsSoundFile.src = "sound_files/fast_walking_foot_steps_sound_1.mp3" ;
			        	protagonistObj.footStepsSoundFile.volume = 0.1 ;
			        


			        if (!protagonistObj.movementAnimationStarted) {
			        	protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
			        }

			
				}

				if (e.key == "4" && protagonistObj.type != "eagle") {

					previousOverallDisplacement.x = overallDisplacement.x ;
					previousOverallDisplacement.y = overallDisplacement.y ;

			        protagonistObj.type = "eagle" ;
			        protagonistObj.totalAnimationFrames = 4 ; // refers to horizontal or vertical depending on the character
			        protagonistObj.currentHorizontalFrameIndex = 0 ;
			        protagonistObj.currentVerticalFrameIndexForMovement = { "south" :  0 , "north" :  3 , "east" :  2 , "west" :  1 } ;
			        protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement[protagonistObj.direction] ;
			        protagonistObj.frameHeight = 80 ;
			        protagonistObj.frameWidth = 80 ;
			        protagonistObj.actualHeight = 60 ;
			        protagonistObj.actualWidth = 80 ;
			        protagonistObj.speed = 4 ;
			        protagonistObj.visionRadius = 450 ; // false -> full visibility
			        protagonistObj.collision = {south : false , north : false , east : false , west : false} ;


			        protagonistImage.src = "character_sprites/eagle_movement_sprite.png" ;

			        protagonistObj.footStepsSoundFile.src = "sound_files/flapping wings sound.mp3" ;
			        protagonistObj.footStepsSoundFile.volume = 0.2 ;


			        if (!protagonistObj.movementAnimationStarted) {
			        	protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
			        }

                    protagonistObj.eagleIntroSoundFile.load() ;
			        protagonistObj.eagleIntroSoundFile.play() ;

			
				}



			} ) ; // event listner for keydown ends here



			document.addEventListener("keyup" , function (e) {

				if (protagonistObj.type != "eagle" && protagonistObj.type != "escapist" )
				{clearInterval(protagonistObj.movementAnimationTimeInterval) ;
				protagonistObj.currentHorizontalFrameIndex = 0 ;
				protagonistObj.movementAnimationStarted = false ;
				protagonistObj.footStepsSoundFile.pause() ;
				protagonistObj.footStepsSoundFile.load() ;}

				if (e.key == 's' || e.key == 'S') {
					protagonistObj.keyPressed.s = false ;
				}
				if (e.key == 'w' || e.key == 'W') {
					protagonistObj.keyPressed.w = false ;
				}
				if (e.key == 'd' || e.key == 'D') {
					protagonistObj.keyPressed.d = false ;
				}
				if (e.key == 'a' || e.key == 'A') {
					protagonistObj.keyPressed.a = false ;
				}

			} ) ; 



			this.draw = function () {

				if (protagonistObj.levelCompleted == false && protagonistObj.gameOver == false) {



				this.cxt.clearRect(0,0,canvas.width,canvas.height) ;

			    this.cxt.drawImage(dungeonBasicLayout,protagonistObj.x-150+overallDisplacement.x , 
			    	                                  protagonistObj.y-150+overallDisplacement.y ) ;

			    if (mainBossDoorKey.visible) 
			    {this.cxt.drawImage( mainBossDoorKeyImage , mainBossDoorKey.x-50+overallDisplacement.x , mainBossDoorKey.y-50+overallDisplacement.y ) ; }

				for (var i = 0; i < coinsCount ; i++) {

					this.cxt.drawImage( coinRotationSprite , coins[i].frameWidth*coins[i].currentFrameIndex , 0 , 
						                coins[i].frameWidth , coins[i].frameHeight , coins[i].x - coins[i].frameWidth/2+overallDisplacement.x , 
				                        coins[i].y - coins[i].frameHeight/2+overallDisplacement.y , coins[i].frameWidth , coins[i].frameHeight ) ;					
				}


			    for (var i = 0; i < dungeonWallsCount ; i++) {

					if (dungeonWalls[i].shadowed) {

						this.cxt.drawImage(wallWithShadow , dungeonWalls[i].x-50+overallDisplacement.x , 
							               dungeonWalls[i].y-50+overallDisplacement.y ) ;
					}					
				}


				for (var i = 0; i < dungeonWallsCount ; i++) {

					if (!dungeonWalls[i].shadowed) {

						this.cxt.drawImage(wallWithoutShadow , dungeonWalls[i].x-50+overallDisplacement.x , 
							               dungeonWalls[i].y-50+overallDisplacement.y ) ;
					}					
				}

				for (var i = 0; i < dungeonPillarsCount ; i++) {

					if (!dungeonPillars[i].shadowed) {

						this.cxt.drawImage(wallWithoutShadow , dungeonPillars[i].x-50+overallDisplacement.x , 
							               dungeonPillars[i].y-50+overallDisplacement.y ) ;
					}					
				}

				for (var i = 0; i < dungeonUpperBoundaryWallsToBeUnshadowedCount ; i++) {

					this.cxt.drawImage(wallWithoutShadow,dungeonUpperBoundaryWallsToBeUnshadowed[i].x-50+overallDisplacement.x , 
						                                 dungeonUpperBoundaryWallsToBeUnshadowed[i].y-50+overallDisplacement.y) ;		                              					
				}

				if (mainBossDoorKey.collected == true) {
				this.cxt.drawImage( mainBossDoorSprite , mainBossDoor.frameWidth*mainBossDoor.currentFrameIndex , 0 , 
					                mainBossDoor.frameWidth , mainBossDoor.frameHeight , 
					                mainBossDoor.x - mainBossDoor.frameWidth/2+overallDisplacement.x , 
					                mainBossDoor.y - mainBossDoor.frameHeight/2+overallDisplacement.y , 
					                mainBossDoor.frameWidth , mainBossDoor.frameHeight ) ;
			    }

			    /*for (var i = 0; i < dungeonNewFloorTilesCount ; i++) {

					this.cxt.drawImage(dungeonFloorTileImage , dungeonNewFloorTiles[i].x-50+overallDisplacement.x , 
						                                  dungeonNewFloorTiles[i].y-50+overallDisplacement.y) ;
					
				}*/


			    this.cxt.drawImage( protagonistImage , protagonistObj.frameWidth*protagonistObj.currentHorizontalFrameIndex , 
				                    protagonistObj.frameHeight*protagonistObj.currentVerticalFrameIndex , protagonistObj.frameWidth , 
				                    protagonistObj.frameHeight , protagonistObj.x - protagonistObj.frameWidth/2 , 
				                    protagonistObj.y - protagonistObj.frameHeight/2 , protagonistObj.frameWidth , protagonistObj.frameHeight ) ;


			    if (protagonistObj.visionRadius){
			    	addDungeonVision() ;
			    }

			    this.cxt.drawImage( healthBarSprite , healthBar.frameWidth*healthBar.currentFrameIndex , 
				                    0 , healthBar.frameWidth , healthBar.frameHeight , healthBar.x , 
				                    healthBar.y , healthBar.frameWidth , healthBar.frameHeight ) ;

			    this.cxt.drawImage(numbersSprite , gameCountdown.frameWidth*gameCountdown.minutes ,
				                   0 , gameCountdown.frameWidth , gameCountdown.frameHeight , protagonistObj.x - gameCountdown.frameWidth - 5 ,
				                   0 , gameCountdown.frameWidth , gameCountdown.frameHeight) ;

			    this.cxt.drawImage(numbersSprite , gameCountdown.frameWidth*(Math.floor(gameCountdown.seconds/10)) ,
				                   0 , gameCountdown.frameWidth , gameCountdown.frameHeight , protagonistObj.x + 5 ,
				                   0 , gameCountdown.frameWidth , gameCountdown.frameHeight) ;

			    this.cxt.drawImage(numbersSprite , gameCountdown.frameWidth*(gameCountdown.seconds%10) ,
				                   0 , gameCountdown.frameWidth , gameCountdown.frameHeight , protagonistObj.x + gameCountdown.frameWidth + 5 ,
				                   0 , gameCountdown.frameWidth , gameCountdown.frameHeight) ;



			    
				this.cxt.drawImage( aimImage , aim.x-aim.frameWidth/2 , aim.y-aim.frameHeight/2 ) ;
			    

			    this.cxt.drawImage(readInstructions , 0 , 0 ) ;




				}

				else{

					if ((protagonistObj.levelCompleted == true && mainBossDoor.currentFrameIndex == mainBossDoor.totalAnimationFrames -1) || 
						 protagonistObj.gameOver == true) {

						protagonistObj.cutSceneAnimationRadius = 5 ;
					    protagonistObj.cutSceneAnimation = true ;
					

		                protagonistObj.cutSceneAnimationTimeInterval = setInterval ( function () {

		            	    cxt.lineWidth = 10 ;
		                    cxt.strokeStyle = "black" ;

		    	            cxt.beginPath() ;
		    	            cxt.arc(protagonistObj.x,protagonistObj.y,protagonistObj.cutSceneAnimationRadius,0,2*Math.PI) ;
		    	            cxt.stroke() ;

		    	            protagonistObj.cutSceneAnimationRadius += 9 ;

		    	            if (protagonistObj.cutSceneAnimationRadius >= 850) {
		    	 	            cxt.clearRect(0,0,canvas.width,canvas.height) ;
		    	 	            protagonistObj.stopRequestingFrame = true ;
		    	 	            clearInterval(protagonistObj.coinRotationAnimationTimeInterval) ;
		    	                clearInterval(protagonistObj.cutSceneAnimationTimeInterval) ;
		    	            }

		                } , 30 ) ;

					}
					

				}


				if (displayInstructions) {
					this.cxt.drawImage(instructions , 0 , 0 ) ;
				}



			}

			


			this.update = function () {

				if (protagonistObj.type != "eagle") {
					previousOverallDisplacement.x = overallDisplacement.x ;
					previousOverallDisplacement.y = overallDisplacement.y ;
				}


				if (protagonistObj.keyPressed.w == true) {


					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "north")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

					    } , 100 ) ;


					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "north" ;
					    protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement["north"] ;

					}		





					if (!protagonistObj.collision.north)
					{overallDisplacement.y += protagonistObj.speed ;}



                    if (protagonistObj.type != "eagle")
                    {
                    	for (var i = 0; i < dungeonPillarsCount; i++) {
                    					
                    					
                    					    if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
                    						        protagonistObj.x+protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)    ||  
                    						        (protagonistObj.x-protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
                    						        protagonistObj.x-protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)  )    &&
                    
                    				    	        (protagonistObj.y+protagonistObj.actualHeight/2-20 <= dungeonPillars[i].y+50+overallDisplacement.y)  &&  
                    				    	        (protagonistObj.y+protagonistObj.actualHeight/2-20 >= dungeonPillars[i].y-50+overallDisplacement.y) )  
                    
                    						        {overallDisplacement.y = protagonistObj.y + protagonistObj.actualHeight/2-20 - (dungeonPillars[i].y + 50) ;
                    						        protagonistObj.collision.north = true;
                    						        break;}
                    
                    					    else 	
                    
                    						    {protagonistObj.collision.north = false;}
                    					  
                    				    }
                    					  
                    				
                    
                    
                    
                    				    if (!protagonistObj.collision.north) {
                    
                                            for (var i = 0; i < dungeonWallsCount; i++) {
                    					
                    				            if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
                    						            protagonistObj.x+protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)    ||  
                    						            (protagonistObj.x-protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
                    						            protagonistObj.x-protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)  )    &&
                    
                    				    	            (protagonistObj.y+protagonistObj.actualHeight/2-20 <= dungeonWalls[i].y+50+overallDisplacement.y)  &&  
                    				    	            (protagonistObj.y+protagonistObj.actualHeight/2-20 >= dungeonWalls[i].y-50+overallDisplacement.y) )  
                    
                    						            {overallDisplacement.y = protagonistObj.y + protagonistObj.actualHeight/2-20 - (dungeonWalls[i].y + 50) ;
                    						            protagonistObj.collision.north = true;
                    						            break;}
                    
                    					        else 	
                    
                    						        {protagonistObj.collision.north = false;}
                    
                    				        }
                    
                    				        if (protagonistObj.y+protagonistObj.actualHeight/2-20 <= dungeonTopBoundary+overallDisplacement.y) 
                    				        {overallDisplacement.y = protagonistObj.y+protagonistObj.actualHeight/2-20 - dungeonTopBoundary ;
                    				        protagonistObj.collision.north = true;}
                    
                    				    }


                    				}				





				}


				if (protagonistObj.keyPressed.d == true) {


					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "east")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "east" ;
					    protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement["east"] ;
					}		





					if (!protagonistObj.collision.east)
					{overallDisplacement.x -= protagonistObj.speed ;}




                if (protagonistObj.type != "eagle")
                {
                	for (var i = 0; i < dungeonPillarsCount; i++) {
                					
                					
                					    if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonPillars[i].y+50+overallDisplacement.y    &&   
                						        protagonistObj.y+protagonistObj.actualHeight/2>dungeonPillars[i].y-50+overallDisplacement.y)    ||  
                						        (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonPillars[i].y+50+overallDisplacement.y    &&   
                						        protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonPillars[i].y-50+overallDisplacement.y)  )    &&
                
                				    	        (protagonistObj.x+protagonistObj.actualWidth/2 >= dungeonPillars[i].x-50+overallDisplacement.x)  && 
                				    	        (protagonistObj.x+protagonistObj.actualWidth/2 <= dungeonPillars[i].x+50+overallDisplacement.x)  )  
                
                						        {overallDisplacement.x = protagonistObj.x + protagonistObj.actualWidth/2 - (dungeonPillars[i].x-50) ;
                						        protagonistObj.collision.east = true;
                						        break;}
                
                					    else 	
                
                						    {protagonistObj.collision.east = false;}
                					  
                				    }
                					  
                				
                
                
                
                				    if (!protagonistObj.collision.east) {
                
                                        for (var i = 0; i < dungeonWallsCount; i++) {
                					
                					
                					        if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonWalls[i].y+50+overallDisplacement.y    &&   
                						            protagonistObj.y+protagonistObj.actualHeight/2>dungeonWalls[i].y-50+overallDisplacement.y)    ||  
                						            (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonWalls[i].y+50+overallDisplacement.y    &&   
                						            protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonWalls[i].y-50+overallDisplacement.y)  )    &&
                
                				    	            (protagonistObj.x+protagonistObj.actualWidth/2 >= dungeonWalls[i].x-50+overallDisplacement.x)   &&
                				    	            (protagonistObj.x+protagonistObj.actualWidth/2 <= dungeonWalls[i].x+50+overallDisplacement.x)   )  
                
                						            {overallDisplacement.x = protagonistObj.x + protagonistObj.actualWidth/2 - (dungeonWalls[i].x-50) ;
                						            protagonistObj.collision.east = true;
                						            break;}
                
                					        else 	
                
                						        {protagonistObj.collision.east = false;}
                					  
                				        }
                
                				        if (protagonistObj.x+protagonistObj.actualWidth/2 >= dungeonRightBoundary+overallDisplacement.x) 
                				        {overallDisplacement.x = protagonistObj.x + protagonistObj.actualWidth/2 - (dungeonRightBoundary) ;
                				        protagonistObj.collision.east = true;}
                
                				    }

                				}




				}


				if (protagonistObj.keyPressed.a == true) {



					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "west")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "west" ;
					    protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement["west"] ;
					}			




					if (!protagonistObj.collision.west)
					{overallDisplacement.x += protagonistObj.speed ;}



                    if (protagonistObj.type != "eagle")
                    {
                    	for (var i = 0; i < dungeonPillarsCount; i++) {
                    					
                    					
                    					    if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonPillars[i].y+50+overallDisplacement.y    &&   
                    						        protagonistObj.y+protagonistObj.actualHeight/2>dungeonPillars[i].y-50+overallDisplacement.y)    ||  
                    						        (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonPillars[i].y+50+overallDisplacement.y    &&   
                    						        protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonPillars[i].y-50+overallDisplacement.y)  )    &&
                    
                    				    	        (protagonistObj.x-protagonistObj.actualWidth/2 <= dungeonPillars[i].x+50+overallDisplacement.x)  &&
                    				    	        (protagonistObj.x-protagonistObj.actualWidth/2 >= dungeonPillars[i].x-50+overallDisplacement.x)  )  
                    
                    						        {overallDisplacement.x = protagonistObj.x - protagonistObj.actualWidth/2 - (dungeonPillars[i].x+50) ;
                    						        protagonistObj.collision.west = true;
                    						        break;}
                    
                    					    else 	
                    
                    						    {protagonistObj.collision.west = false;}
                    					  
                    				    }
                    					  
                    				
                    
                    
                    
                    				    if (!protagonistObj.collision.west) {
                    
                                            for (var i = 0; i < dungeonWallsCount; i++) {
                    					
                    					
                    					        if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonWalls[i].y+50+overallDisplacement.y    &&   
                    						            protagonistObj.y+protagonistObj.actualHeight/2>dungeonWalls[i].y-50+overallDisplacement.y)    ||  
                    						            (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonWalls[i].y+50+overallDisplacement.y    &&   
                    						            protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonWalls[i].y-50+overallDisplacement.y)  )    &&
                    
                    				    	            (protagonistObj.x-protagonistObj.actualWidth/2 <= dungeonWalls[i].x+50+overallDisplacement.x)  &&
                    				    	            (protagonistObj.x-protagonistObj.actualWidth/2 >= dungeonWalls[i].x-50+overallDisplacement.x)   )  
                    
                    						            {overallDisplacement.x = protagonistObj.x - protagonistObj.actualWidth/2 - (dungeonWalls[i].x+50) ;
                    						            protagonistObj.collision.west = true;
                    						            break;}
                    
                    					        else 	
                    
                    						        {protagonistObj.collision.west = false;}
                    					  
                    				        }
                    
                    				        if (protagonistObj.x-protagonistObj.actualWidth/2 <= dungeonLeftBoundary+overallDisplacement.x) 
                    
                    				        {overallDisplacement.x = protagonistObj.x - protagonistObj.actualWidth/2 - dungeonLeftBoundary ;
                    				        protagonistObj.collision.west = true;}
                    
                    				    }

                    				}


					
				}


				if (protagonistObj.keyPressed.s == true) {



					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "south")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "south" ;
					    protagonistObj.currentVerticalFrameIndex = protagonistObj.currentVerticalFrameIndexForMovement["south"] ;
					}			

					
					if (!protagonistObj.collision.south)
					{overallDisplacement.y -= protagonistObj.speed ;}
					



                    if (protagonistObj.type != "eagle")
                    {
                    	for (var i = 0; i < dungeonPillarsCount; i++) {
                    					
                    					
                    					    if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
                    						        protagonistObj.x+protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)    ||  
                    						        (protagonistObj.x-protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
                    						        protagonistObj.x-protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)  )    &&
                    
                    				    	        (protagonistObj.y+protagonistObj.actualHeight/2 >= dungeonPillars[i].y-50+overallDisplacement.y)  &&
                    				    	        (protagonistObj.y+protagonistObj.actualHeight/2 <= dungeonPillars[i].y+50+overallDisplacement.y) )  
                    
                    						        {overallDisplacement.y = protagonistObj.y + protagonistObj.actualHeight/2 - (dungeonPillars[i].y - 50) ;
                    						        protagonistObj.collision.south = true;
                    						        break;}
                    
                    					    else 	
                    
                    						    {protagonistObj.collision.south = false;}
                    					  
                    				    }
                    					  
                    				
                    
                    
                    
                    				    if (!protagonistObj.collision.south) {
                    
                                            for (var i = 0; i < dungeonWallsCount; i++) {
                    					
                    				            if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
                    						            protagonistObj.x+protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)    ||  
                    						            (protagonistObj.x-protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
                    						            protagonistObj.x-protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)  )    &&
                    
                    				    	            (protagonistObj.y+protagonistObj.actualHeight/2 >= dungeonWalls[i].y-50+overallDisplacement.y)  &&
                    				    	            (protagonistObj.y+protagonistObj.actualHeight/2 <= dungeonWalls[i].y+50+overallDisplacement.y)   )  
                    
                    						            {overallDisplacement.y = protagonistObj.y + protagonistObj.actualHeight/2 - (dungeonWalls[i].y-50) ;
                    						            protagonistObj.collision.south = true;
                    						            break;}
                    
                    					        else 	
                    
                    						        {protagonistObj.collision.south = false;}
                    
                    				        }
                    
                    				        if (protagonistObj.y+protagonistObj.actualHeight/2 >= dungeonBottomBoundary+overallDisplacement.y) 
                    
                    				        {overallDisplacement.y = protagonistObj.y+protagonistObj.actualHeight/2 - dungeonBottomBoundary ;
                    				        protagonistObj.collision.south = true;}
                    
                    				    }

                    				}



					
				}








				for (var i = 0; i < coinsCount ; i++) {

					if (protagonistObj.type != "eagle")
					{
						if (protagonistObj.x>coins[i].x-40+overallDisplacement.x && protagonistObj.x<coins[i].x+40+overallDisplacement.x &&
						    protagonistObj.y+protagonistObj.actualHeight/2>coins[i].y-20+overallDisplacement.y && 
						    protagonistObj.y+protagonistObj.actualHeight/2<coins[i].y+50+overallDisplacement.y) 
					
						    { protagonistObj.coinsCollected ++ ;
							  coins.splice(i,1) ;
							  coinsCount -- ;
							  console.log("coins collected : " + protagonistObj.coinsCollected) ;
					
							  protagonistObj.coinCollectionSoundFile.pause();
							  protagonistObj.coinCollectionSoundFile.load();
							  protagonistObj.coinCollectionSoundFile.play();
					
							  break; }
					}
					
				}





                
                if (!mainBossDoorKey.collected && protagonistObj.type != "eagle")
				if (protagonistObj.x>mainBossDoorKey.x-50+overallDisplacement.x && protagonistObj.x<mainBossDoorKey.x+50+overallDisplacement.x &&
					protagonistObj.y>mainBossDoorKey.y-50+overallDisplacement.y && 
					protagonistObj.y<mainBossDoorKey.y+50+overallDisplacement.y) 

					{ protagonistObj.mainBossDoorKeyCollectionSoundFile.play();
					  mainBossDoorKey.collected = true ;

					  for (var randPillarIndex ; ; ) {

					  	randPillarIndex = Math.floor(100*Math.random()/(100/dungeonPillarsCount)) ;

					  	if (dungeonPillars[randPillarIndex].shadowed) {
					  		mainBossDoor = new door(dungeonPillars[randPillarIndex].x , dungeonPillars[randPillarIndex].y+25) ;
					  		break;
					  	}else{
					  		if (dungeonWalls[randPillarIndex].shadowed) {
					  			mainBossDoor = new door(dungeonWalls[randPillarIndex].x , dungeonWalls[randPillarIndex].y+25) ;
					  			break;
					  		}else{continue;}
					  	}
					  
					  }

				    }


				if (!mainBossDoorKey.collected && !protagonistObj.gameOver) {

					if (  (50/Math.sqrt(Math.pow(protagonistObj.x-(mainBossDoorKey.x + overallDisplacement.x),2) + 
							   Math.pow(protagonistObj.y-(mainBossDoorKey.y + overallDisplacement.y),2)))   >=1  ) 
						{

							protagonistObj.mainBossDoorKeyClueSoundFile.volume = 1 ;

						}
						else
						{

							protagonistObj.mainBossDoorKeyClueSoundFile.volume = (50/Math.sqrt(Math.pow(protagonistObj.x-(mainBossDoorKey.x + 
					        overallDisplacement.x),2) + Math.pow(protagonistObj.y-(mainBossDoorKey.y + overallDisplacement.y),2))) ;

						}

					protagonistObj.mainBossDoorKeyClueSoundFile.play() ;
				}
				else{
					if ( !protagonistObj.gameOver && mainBossDoor.currentFrameIndex == 0) {

						if (  (30/Math.sqrt(Math.pow(protagonistObj.x-(mainBossDoor.x + overallDisplacement.x),2) + 
							   Math.pow(protagonistObj.y-(mainBossDoor.y + overallDisplacement.y),2)))   >=1  ) 
						{

							protagonistObj.mainBossDoorKeyClueSoundFile.volume = 1 ;

						}
						else
						{

							protagonistObj.mainBossDoorKeyClueSoundFile.volume = (30/Math.sqrt(Math.pow(protagonistObj.x-(mainBossDoor.x + 
					        overallDisplacement.x),2) + Math.pow(protagonistObj.y-(mainBossDoor.y + overallDisplacement.y),2))) ;

						}

						

					    protagonistObj.mainBossDoorKeyClueSoundFile.play() ;
					}
				}   





			} // end of update
      








		}// end of Game Constructor





		function initializeNewLevel () {


		mainBossDoorKey = undefined ;
		mainBossDoor = undefined ;  

        

		dungeonPillars = [] ;
		dungeonPillarsCount = 0 ;

		dungeonPillarsByDefault = [] ;     // i introduced this for the sake of removing pillars
		dungeonPillarsByDefaultCount = 0 ; // if pillars are not removed this is no diff from dungeonPillars


		dungeonNewFloorTiles = [] ;
		dungeonNewFloorTilesCount = 0 ;
		

		dungeonWalls = [] ;
		dungeonWallsCount = 0 ;

        dungeonUpperBoundaryWallsToBeUnshadowed = [] ;
        dungeonUpperBoundaryWallsToBeUnshadowedCount = 0 ;


		coins = [] ;
		coinsCount = 0 ;


		// remember camera is fixed to the protagonist, so the entire surrounding moves, so is the overallDisplacement object
		overallDisplacement = { x:0 , y:0 } ;

		previousOverallDisplacement = { x:0 , y:0 } ;


		// our game's protagonist
		protagonistObj = new protagonist() ;

		healthBar = new bar() ;

		gameCountdown = new countdown () ;







		for (var i = 0 ; i < 7 ; i++) {
			for (var j = 0 ; j < 12 ; j++) {

				dungeonPillars[dungeonPillarsCount] = new pillar( protagonistObj.x+100+j*200 , protagonistObj.y+100+i*200 ) ;
				dungeonPillarsCount++ ;

				dungeonPillarsByDefault[dungeonPillarsByDefaultCount] = new pillar( protagonistObj.x+100+j*200 , protagonistObj.y+100+i*200 ) ;
				dungeonPillarsByDefaultCount++ ;
				
			}
			
		}


        /*

        // im removing few pillars 
        // just removing is not sufficient, i need to change the shadowed property of appropriate walls and pillars

		for (var rowNo = 0; rowNo < 7 ; rowNo++) {

			rand = Math.floor(100*Math.random()/(100/12)) ;

			dungeonNewFloorTiles[rowNo] = new dungeonFloorTile(dungeonPillars[rowNo*11 + rand].x , dungeonPillars[rowNo*11 + rand].y) ; 

			dungeonNewFloorTilesCount ++ ;

			dungeonPillars.splice(rowNo*11 + rand,1) ;
			dungeonPillarsCount -- ;
			
		}*/

        

        //when the 1st row pillars have nothern walls, corresponding boundary walls should unshadowed as the basic layout has all upper boundary walls shadowed by default.


		for (var i = 0 , rand ; i < dungeonPillarsCount ; i++) {

            // as said earlier each pillar has a wall and it can be in either of 4 directions which is randomly generated
            rand = Math.floor(100*Math.random()/25) ; // 0 -> east , 1 -> south , 2 -> west , 3 -> north . 
            
            
            // avoiding horizontally consectutive walls with similar type to create more crooked maze
            // && (rand == 0 || rand == 2) include this along with i>0 condition to avoid formation of long continuous horizontal walls alone
            if (i>0) {
            	if(dungeonWalls[dungeonWallsCount-1].type == rand) 
            		{rand = Math.floor(100*Math.random()/25) ;}//{i--; continue;}//
            }

            // avoiding vertically consectutive walls with similar type to create more crooked maze
            // && (rand == 1 || rand == 3) include this along with i>11 condition to avoid formation of long continuous vertical walls alone
            if (i>11) {
            	if (dungeonWalls[dungeonWallsCount-12].type == rand) 
            		{rand = Math.floor(100*Math.random()/25) ;}//{i--; continue;}//
            }
            




            // avoiding formation of closed boxes/rooms formed by 4 adjacent pillars like this ::
            if (i>12) {
            	// anticlockwise orientation of walls to form a room/box
            	if (dungeonWalls[dungeonWallsCount-1].type == 0 && dungeonWalls[dungeonWallsCount-12].type == 2 
            	                         && dungeonWalls[dungeonWallsCount-13].type == 1) {
            	    if (rand == 3) {i--; continue;}
                }

                // clockwise orientation of walls to form a room/box
                if (dungeonWalls[dungeonWallsCount-1].type == 3 && dungeonWalls[dungeonWallsCount-12].type == 1 
            	                         && dungeonWalls[dungeonWallsCount-13].type == 0) {
            	    if (rand == 2) {i--; continue;}
                }
            }


            	

			if (rand == 0) {

				dungeonWalls[dungeonWallsCount] = new wall (dungeonPillars[i].x+100 , dungeonPillars[i].y) ;
			    dungeonWalls[dungeonWallsCount].shadowed = true ;
			    // eastern and western walls are always shadowed and do not affect other pillar's shadowed property

			} else { if (rand == 2) {

				    // avoiding overlapping of present pillar's western wall to the horizontally preceeding pillar's eastern wall
				    if ( i>0 && dungeonWalls[dungeonWallsCount-1].x == dungeonPillars[i].x-100 ) 
				        {i--; continue;}

					dungeonWalls[dungeonWallsCount] = new wall (dungeonPillars[i].x-100 , dungeonPillars[i].y) ;
				    dungeonWalls[dungeonWallsCount].shadowed = true ;
				    // eastern and western walls are always shadowed and do not affect other pillar's shadowed property

				} else { if (rand == 1) {

					    dungeonWalls[dungeonWallsCount] = new wall (dungeonPillars[i].x , dungeonPillars[i].y+100) ;
					    dungeonWalls[dungeonWallsCount].shadowed = false ;
					    dungeonPillars[i].shadowed = false ;
					    // nothern and southern walls are always not shadowed coz they always lie in between 2 adjacent pillars
					    // southern wall affects it's pillar's shadowed property, coz the wall becomes exposed before it's pillar

				    }

				}
			}

			if (rand == 3) {
				if (i > 11) {

					// avoiding overlapping of present pillar's northern wall to the vertically preceeding pillar's southern wall
					if ( dungeonWalls[dungeonWallsCount-12].y == dungeonPillars[i].y-100 ) 
					 {i--; continue;}


					dungeonWalls[dungeonWallsCount] = new wall(dungeonPillars[i].x , dungeonPillars[i].y-100) ;
					dungeonWalls[dungeonWallsCount].shadowed = false ;
				    dungeonPillars[i-12].shadowed = false ;
				    // nothern and southern walls are always not shadowed coz they always lie in between 2 adjacent pillars
					// nothern wall affects vertically preceeding pillar's shadowed property, coz the wall removes that pillar's exposure

				} else { // 1st row pillars

					    dungeonWalls[dungeonWallsCount] = new wall(dungeonPillars[i].x , dungeonPillars[i].y-100) ;
					    dungeonWalls[dungeonWallsCount].shadowed = false ;

					    dungeonUpperBoundaryWallsToBeUnshadowed[dungeonUpperBoundaryWallsToBeUnshadowedCount]    =    
					                                    new dungeonUpperBoundaryWall(dungeonPillars[i].x , dungeonPillars[i].y-200) ;

					    dungeonUpperBoundaryWallsToBeUnshadowedCount++ ;
					    // nothern walls of the pillars from the 1st row affect the dungeon's corresponding upper boundary walls

				}
			    


			}

			dungeonWalls[dungeonWallsCount].type = rand ;

			dungeonWallsCount++ ;			
		}



		// randPillarIndex -> 3 to 83
		for (var randPillarIndex = Math.floor(100*Math.random()/(100/81)) + 3 , rand ; ; randPillarIndex = Math.floor(100*Math.random()/(100/81)) + 3 ) 
		{
			if (randPillarIndex == (12 || 13 || 14 || 24 || 25 || 26)) {continue;}

			// so the key wont be anywhere near the pillars with index 0,1,2,12,13,14,24,25,26

			rand = Math.floor(100*Math.random()/50) ;

		    // 0 -> south-east , 1 -> north-east


			if (rand == 0) {

				mainBossDoorKey = new doorKey(dungeonPillarsByDefault[randPillarIndex].x+100 , 
				                              dungeonPillarsByDefault[randPillarIndex].y+100) ; 
		    }

			if (rand == 1) {

				mainBossDoorKey = new doorKey(dungeonPillarsByDefault[randPillarIndex].x+100 , 
				                              dungeonPillarsByDefault[randPillarIndex].y-100) ; 
		    }

			break ;
			
		}

       


        // generating coins like how we did for walls
		for (var i = 0 , rand ; i < dungeonPillarsByDefaultCount ; i++) {


            // each pillar has a coin , it can be in either of the 4 directions (can also be inside the wall)
            // or be inside the pillar ...... do this in the later stages
            rand = Math.floor(100*Math.random()/25) ; // 0 -> east , 1 -> south , 2 -> west , 3 -> north 
            // 4 -> inside the pillar ..... do this in the later stages , u need to add visibility of coin as pillars are part of basic layout
            
            
                      	
			if (rand == 0) {

				coins[coinsCount] = new coin (dungeonPillarsByDefault[i].x+100 , dungeonPillarsByDefault[i].y) ;

			} else { if (rand == 2) {

				    // avoiding overlapping of present pillar's western coin to the horizontally preceeding pillar's eastern coin
				    if ( i>0 && coins[coinsCount-1].x == dungeonPillarsByDefault[i].x-100 ) 
				        {i--; continue;}

					coins[coinsCount] = new coin (dungeonPillarsByDefault[i].x-100 , dungeonPillarsByDefault[i].y) ;

				} else { if (rand == 1) {

					    coins[coinsCount] = new coin (dungeonPillarsByDefault[i].x , dungeonPillarsByDefault[i].y+100) ;

				    }

				}
			}

			if (rand == 3) {
				if (i > 11) {

					// avoiding overlapping of present pillar's northern coin to the vertically preceeding pillar's southern coin
					if ( coins[coinsCount-12].y == dungeonPillarsByDefault[i].y-100 ) 
					 {i--; continue;}

				} 
				coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x , dungeonPillarsByDefault[i].y-100) ;	    
			}

			//if (rand == 4) {coins[coinsCount] = new coin (dungeonPillars[i].x , dungeonPillars[i].y) ;}
            


			coinsCount++ ;

						
		}        


		

		// now this is the second step of coin generation , in the first step coins are generated only vertically and horizontally but not diagonally
		for (var i = 0 , rand ; i < dungeonPillarsByDefaultCount ; i++) {


            rand = Math.floor(100*Math.random()/50) ; // 0 -> north-east , 1 -> south-west
            
            

			if (rand == 0) {
				if (i > 11) {

					// avoiding overlapping of present pillar's north-eastern coin to the vertically preceeding pillar's horizontally succeeding pillar's south-western coin
					if ((coins[coinsCount-12+1].y == dungeonPillarsByDefault[i].y-100) && (coins[coinsCount-12+1].x == dungeonPillarsByDefault[i].x+100)) 
					    {coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x-100 , dungeonPillarsByDefault[i].y+100) ;}//south-western coin
					else 
						{coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x+100 , dungeonPillarsByDefault[i].y-100) ;}// north-eastern coin

				}else {coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x+100 , dungeonPillarsByDefault[i].y-100) ;}// north-eastern coin
					    
			}

			if (rand == 1) {coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x-100 , dungeonPillarsByDefault[i].y+100) ;}


			coinsCount++ ;

						
		}


		





		// should draw the image only after it is loaded

		if (drawEverything && level == 1) {

			drawInitialFrame() ;

		}





			protagonistObj.coinRotationAnimationTimeInterval = setInterval(function () {

						    for (var i = 0; i < coinsCount; i++) {

						    	if (coins[i].currentFrameIndex == coins[i].totalAnimationFrames -1 ) {
							        coins[i].currentFrameIndex = 0 ;
						            } else { coins[i].currentFrameIndex++ ; }						    	
						    }

					    },70) ;



			protagonistObj.cutSceneAnimationTimeInterval = setInterval( function () {
				cxt.lineWidth = 20 ;
				cxt.strokeStyle = "black" ;


				cxt.clearRect(0,0,canvas.width,canvas.height) ;

				drawInitialFrame() ;

				for (var i = protagonistObj.cutSceneAnimationRadius ; i <= 850 ; i += 19 ) {				
				    cxt.beginPath();
				    cxt.arc(760,370,i,0,2*Math.PI) ;
				    cxt.stroke() ;	
				}

				if (protagonistObj.cutSceneAnimationRadius >= 850) {


					protagonistObj.cutSceneAnimationRadius = 10 ;
					protagonistObj.cutSceneAnimation = false ;



			        gameCountdown.timeInterval = setInterval( function () {

				        if (gameCountdown.seconds == 0) {

					        if (gameCountdown.minutes == 0) {
					        	gameCountdown.timeOutSoundFile.play() ;
					        	protagonistObj.mainBossDoorKeyClueSoundFile.load() ;
					        	protagonistObj.mainBossDoorKeyClueSoundFile.pause() ;
						        clearInterval(gameCountdown.timeInterval) ; 
						        protagonistObj.gameOver = true ;
					        }
					        else{
					        	gameCountdown.minutes -- ;
					        	gameCountdown.countdownMinuteReminderSoundFile.play() ;
					        }

					        gameCountdown.seconds = 59 ;

					        

				        }else{gameCountdown.seconds -- ;}

				        if (gameCountdown.seconds == 30 && gameCountdown.minutes == 0) 
				        	{gameCountdown.countdownMinuteReminderSoundFile.play() ;}

				        if (gameCountdown.seconds <= 15 && gameCountdown.minutes == 0) {
				        	    gameCountdown.lastFewSecondsCountdownSoundFile.load() ;
					        	gameCountdown.lastFewSecondsCountdownSoundFile.play() ;
					        }

			        }, 950 ) ;



					clearInterval(protagonistObj.cutSceneAnimationTimeInterval) ;


				}else{protagonistObj.cutSceneAnimationRadius += 19 ;}

			} , 50 ) ;






			



		} // end of initializeNewLevel






		function drawInitialFrame () {

			// drawing the basic dungeon layout
			cxt.drawImage(dungeonBasicLayout,protagonistObj.x-150,protagonistObj.y-150) ;

			if (mainBossDoorKey.visible) {
				cxt.drawImage( mainBossDoorKeyImage , mainBossDoorKey.x-50 , mainBossDoorKey.y-50 ) ;
			}         	

			

			for (var i = 0; i < coinsCount ; i++) {

				cxt.drawImage( coinRotationSprite , coins[i].frameWidth*coins[i].currentFrameIndex , 
				               0 , coins[i].frameWidth , coins[i].frameHeight , coins[i].x - coins[i].frameWidth/2 , 
				               coins[i].y - coins[i].frameHeight/2 , coins[i].frameWidth , coins[i].frameHeight ) ;					
			}

			


			

				// drawing walls with shadow
			for (var i = 0; i < dungeonWallsCount ; i++) {

				if (dungeonWalls[i].shadowed) {

					cxt.drawImage(wallWithShadow,dungeonWalls[i].x-50,dungeonWalls[i].y-50) ;
				}					
			}
			

			

			// drawing walls with no shadow
			for (var i = 0; i < dungeonWallsCount ; i++) {

				if (!dungeonWalls[i].shadowed) {

					cxt.drawImage(wallWithoutShadow,dungeonWalls[i].x-50,dungeonWalls[i].y-50) ;
				}					
			}

			// updating the pillars with no shadow
			for (var i = 0; i < dungeonPillarsCount ; i++) {

				if (!dungeonPillars[i].shadowed) {

					cxt.drawImage(wallWithoutShadow,dungeonPillars[i].x-50,dungeonPillars[i].y-50) ;
				}					
			}

			// updating the dungeon's upper boundary walls with no shadow
			for (var i = 0; i < dungeonUpperBoundaryWallsToBeUnshadowedCount ; i++) {

				cxt.drawImage(wallWithoutShadow,dungeonUpperBoundaryWallsToBeUnshadowed[i].x-50 , 
						      dungeonUpperBoundaryWallsToBeUnshadowed[i].y-50) ;		                              					
			}

			

			/*if (drawDungeonfloorTile) {

				for (var i = 0; i < dungeonNewFloorTilesCount ; i++) {

					cxt.drawImage(dungeonFloorTileImage,dungeonNewFloorTiles[i].x-50,dungeonNewFloorTiles[i].y-50) ;
					
				}
			}*/

			// drawing the protagonist
			
			cxt.drawImage( protagonistImage , protagonistObj.frameWidth*protagonistObj.currentHorizontalFrameIndex , 
				           protagonistObj.frameHeight*protagonistObj.currentVerticalFrameIndex , protagonistObj.frameWidth , 
				           protagonistObj.frameHeight , protagonistObj.x - protagonistObj.frameWidth/2 , 
				           protagonistObj.y - protagonistObj.frameHeight/2 , protagonistObj.frameWidth , protagonistObj.frameHeight ) ;
			


			if(protagonistObj.visionRadius){
				addDungeonVision() 
			};

			 

		}





		function addDungeonVision () {

			cxt.lineWidth = protagonistObj.visionRadius/15 ;

			for (var i = 50 ; i <= protagonistObj.visionRadius ; i += (protagonistObj.visionRadius/15)/2 ) {

			 cxt.strokeStyle = "rgba(0,0,0," + i/protagonistObj.visionRadius + ")" ;

			    cxt.beginPath() ;
		    	cxt.arc(protagonistObj.x,protagonistObj.y,i,0,2*Math.PI) ;
		    	cxt.stroke() ;
			    	
			}

			cxt.lineWidth = (850 - protagonistObj.visionRadius) ;
			cxt.strokeStyle = "black" ;

			cxt.beginPath() ;
		    cxt.arc(protagonistObj.x,protagonistObj.y,protagonistObj.visionRadius + (850 - protagonistObj.visionRadius)/2 ,0,2*Math.PI) ;
		    cxt.stroke()
		}



		






		var game = new Game() ;



		

		function gameLoop() {

			if (!protagonistObj.cutSceneAnimation){
				game.update() ;			
			    game.draw() ;
			}
			
			if (!protagonistObj.stopRequestingFrame)
			{window.requestAnimationFrame(gameLoop) ;}
		    else{

		    	if (protagonistObj.levelCompleted) {
		    		cancelAnimationFrame(myVar);

		    	    setTimeout ( function () {
		    		    startNewLevel() ;
		    	    } , 2500 );
		    	}		        

		    }
		
		}


		var myVar ;


		function startNewLevel () {

			initializeNewLevel() ;
			myVar = window.requestAnimationFrame(gameLoop) ;			
		
		}

		 

		startNewLevel();


	</script>
</body>
</html>