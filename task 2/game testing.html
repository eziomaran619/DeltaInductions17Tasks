<!DOCTYPE html>
<html>
<head>
	<title>RogueLike Dungeon Crawler</title>

	<style type="text/css">

		#gameCanvas {
			background-color: black ; 
			display: block ; /* to avoid scroll bars */
		}

	</style>
</head>
<body style="background-color: black ;">

	<canvas id="gameCanvas" width ="1520" height = "740" style="cursor: none;" onmousemove="setAimPosition(event)"></canvas> 

	<script type="text/javascript">  //initially draw the basic layout at 610 , 220 i.e top left corner co-ordinates
		
		'use strict'

		var canvas = document.getElementById("gameCanvas") , cxt = canvas.getContext("2d") ;

		function mouseAim () {
			this.x = 100 ;
			this.y = 100 ;
			this.frameHeight = 100 ;
			this.frameWidth = 100 ;
		}

		var aim = new mouseAim() ;

		var aimImage = document.createElement("IMG") ;
		aimImage.src = "mouse_aim.png" ;

		var drawAimImage = false ;




		function setAimPosition (e) {
			aim.x = e.clientX - canvas.offsetLeft ;
			aim.y = e.clientY - canvas.offsetTop ;
		}





		var dungeonTopBoundary = 320 , dungeonBottomBoundary = 1820 , dungeonLeftBoundary = 710 , dungeonRightBoundary = 3210 ; 

		var level = 1 ;

		//the backgrond image
		var dungeonBasicLayout = document.createElement("IMG") ;
		dungeonBasicLayout.src = "dungeon_basic_layout.png" ;

		var drawEverything = false ;

		// protagonist object constructor
		function protagonist () {
			this.x = 760 ;
			this.y = 370 ;
			this.type = "intelligent" ;
			this.totalAnimationFrames = 8 ; // refers to horizontal or vertical depending on the character
			this.currentHorizontalFrameIndex = 0 ;
			this.currentVerticalFrameIndex = 0 ;
			this.spriteAnimation = "horizontal" ;
			this.frameHeight = 70 ;
			this.frameWidth = 70 ;
			this.actualHeight = 70 ;
			this.actualWidth = 40 ;
			this.direction = "south" ;
			this.speed = 20 ;
			this.collision = {south : false , north : false , east : false , west : false} ;
			this.movementAnimationTimeInterval ;
			this.movementAnimationStarted = false ;
			this.coinRotationAnimationTimeInterval ;
			this.coinsCollected = 0 ;
			this.cutSceneAnimationTimeInterval ;
			this.cutSceneAnimationRadius = 5 ;
			this.stopRequestingFrame = false ;
			this.levelCompleted = false ;
			this.cutSceneAnimation = true ;
			this.visionRadius = false ; // 600 is playable , false -> full visibility

			this.footStepsSoundFile = document.createElement("AUDIO") ;
			this.footStepsSoundFile.src = "sound_files/fast_walking_foot_steps_sound_1.mp3" ;
			this.footStepsSoundFile.volume = 0.4 ;

			this.coinCollectionSoundFile = document.createElement("AUDIO") ;
			this.coinCollectionSoundFile.src = "sound_files/magic_chime_on_collecting_coin.mp3" ;
			this.coinCollectionSoundFile.volume = 0.05 ;

			this.mainBossDoorKeyCollectionSoundFile = document.createElement("AUDIO") ;
			this.mainBossDoorKeyCollectionSoundFile.src = "sound_files/magic_chime_on_collecting_the_keys.mp3" ;

			this.mainBossDoorKeyClueSoundFile = document.createElement("AUDIO") ;
			this.mainBossDoorKeyClueSoundFile.src = "sound_files/main_boss_door_key_sound_clue.mp3" ;

			this.mainBossDoorOpeningSoundFile = document.createElement("AUDIO") ;
			this.mainBossDoorOpeningSoundFile.src = "sound_files/azumanga_on_finishing_level.mp3" ;
			
		}

		// to avoid background being drawn over the other images as loading background image takes longer time due to bigger size
		var drawProtagonist = false , drawWallWithShadow = false , drawWallWithoutShadow = false ;

		// protagonist image
		var protagonistImage = document.createElement("IMG") ;
		protagonistImage.src = "character_sprites/protagonist_movement_sprite.png" ;
		
		// wall with shadow image
		var wallWithShadow = document.createElement("IMG") ;
		wallWithShadow.src = "wall_with_shadow.png" ;

		// wall without shadow image
		var wallWithoutShadow = document.createElement("IMG") ;
		wallWithoutShadow.src = "wall_without_shadow.png" ;



		var drawCoinRotationSprite = false , drawMainBossDoorKeyImage = false ;


        var coinRotationSprite = document.createElement("IMG") ;
		coinRotationSprite.src = "sprites/rotating_coin_sprite.png" ;		

		var mainBossDoorKeyImage = document.createElement("IMG") ;
		mainBossDoorKeyImage.src = "key.png" ;

		var mainBossDoorSprite = document.createElement("IMG") ;
		mainBossDoorSprite.src = "sprites/main_boss_door_sprite.png" ;

		var drawDungeonfloorTile = false ;

		var dungeonFloorTileImage = document.createElement("IMG") ;
		dungeonFloorTileImage.src = "dungeon_floor_tile.png" ;
		



		// pillar constructor
		function pillar(X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
			this.shadowed = true ; 
			// probability ratio of pillar to be shadowed to not shadowed is 3:1 for last row pillars and is 3:2 for other pillars
			// as the probability to be shadowed is more, it is made default
		}


        // each pillar has one and only wall
		function wall (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
			this.shadowed ; // here the probability ratio is unity, so no bias
			this.type ;
		}

        function dungeonUpperBoundaryWall (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
		}

		function coin (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.frameWidth = 40 ;
			this.frameHeight = 40 ;
			this.totalAnimationFrames = 10 ;
			this.currentFrameIndex = 0 ;
		}


		function door(X,Y) {
			this.x = X ;
			this.y = Y ;
			this.frameWidth = 237/6 ;
			this.frameHeight = 50 ;
			this.totalAnimationFrames = 6 ;
			this.currentFrameIndex = 0 ;
			this.doorOpeningAnimationTimeInterval ;
		}



		function doorKey(X,Y) {
			this.x = X ;
			this.y = Y ;
			this.collected = false ;
			this.visible = true ;
		}

		function dungeonFloorTile (X,Y) {
			this.x = X ;
			this.y = Y ;
			this.width = 100 ;
			this.height = 100 ;
		}





		var mainBossDoorKey = undefined , mainBossDoor = undefined ; 

		var dungeonPillars = undefined , dungeonPillarsCount = undefined ;

		var dungeonPillarsByDefault = undefined , dungeonPillarsByDefaultCount = undefined ;

		var dungeonNewFloorTiles = undefined , dungeonNewFloorTilesCount = undefined ;
		

		var dungeonWalls = undefined , dungeonWallsCount = undefined ;

        var dungeonUpperBoundaryWallsToBeUnshadowed = undefined , dungeonUpperBoundaryWallsToBeUnshadowedCount = undefined ;


		var coins = undefined , coinsCount = undefined ;


		// remember camera is fixed to the protagonist, so the entire surrounding moves, so is the overallDisplacement object
		var overallDisplacement = undefined ;

		// our game's protagonist
		var protagonistObj = undefined ;





		


		wallWithoutShadow.onload = function () { drawWallWithoutShadow = true ; }

		wallWithShadow.onload = function () { drawWallWithShadow = true ; }
		
		protagonistImage.onload = function () { drawProtagonist = true ; }

		coinRotationSprite.onload = function () { drawCoinRotationSprite = true ; }

		mainBossDoorKeyImage.onload = function () { drawMainBossDoorKeyImage = true ; }

		dungeonFloorTile.onload = function () { drawDungeonfloorTile = true ; }

		aimImage.onload = function () { drawAimImage = true ; }

		dungeonBasicLayout.onload = function () { drawEverything = true ; }


		




       


		function Game() {

			this.cxt = canvas.getContext("2d") ;

			document.addEventListener("keydown" , function (e) {
				if ( (e.key == "e" || e.key == "E") && mainBossDoorKey.collected == true && 
					  mainBossDoor.currentFrameIndex != mainBossDoor.totalAnimationFrames -1 ) {

					if (protagonistObj.x>mainBossDoor.x-50+overallDisplacement.x && 
						protagonistObj.x<mainBossDoor.x+50+overallDisplacement.x &&
					    protagonistObj.y>mainBossDoor.y+75-50+overallDisplacement.y && 
					    protagonistObj.y<mainBossDoor.y+75+50+overallDisplacement.y) {

						mainBossDoor.doorOpeningAnimationTimeInterval = setInterval(function () {

							if (mainBossDoor.currentFrameIndex == mainBossDoor.totalAnimationFrames -1 ) {

								clearInterval(mainBossDoor.doorOpeningAnimationTimeInterval) ;

								protagonistObj.mainBossDoorOpeningSoundFile.play() ;

								protagonistObj.levelCompleted = true ;

								level ++ ;
							    
						        } else { mainBossDoor.currentFrameIndex++ ; }

						},80) ;
					}

				}
			
			} ) ;


			document.addEventListener("keydown" , function (e) {

               
				if ((e.key === "s" || e.key === "S") && protagonistObj.cutSceneAnimation == false) {

					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "south")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

						    //overallDisplacement.y -= protagonistObj.speed ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "south" ;
					    protagonistObj.currentVerticalFrameIndex = 0 ;
					}			




                    for (var i = 0; i < dungeonPillarsCount; i++) {
					
					
					    if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
						        protagonistObj.x+protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)    ||  
						        (protagonistObj.x-protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
						        protagonistObj.x-protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)  )    &&

				    	        (protagonistObj.y+protagonistObj.actualHeight/2 == dungeonPillars[i].y-50+overallDisplacement.y)   )  

						        {protagonistObj.collision.south = true;
						        break;}

					    else 	

						    {protagonistObj.collision.south = false;}
					  
				    }
					  
				



				    if (!protagonistObj.collision.south) {

                        for (var i = 0; i < dungeonWallsCount; i++) {
					
				            if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
						            protagonistObj.x+protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)    ||  
						            (protagonistObj.x-protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
						            protagonistObj.x-protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)  )    &&

				    	            (protagonistObj.y+protagonistObj.actualHeight/2 == dungeonWalls[i].y-50+overallDisplacement.y)   )  

						            {protagonistObj.collision.south = true;
						            break;}

					        else 	

						        {protagonistObj.collision.south = false;}

				        }

				        if (protagonistObj.y+protagonistObj.actualHeight/2 == dungeonBottomBoundary+overallDisplacement.y) 
				        {protagonistObj.collision.south = true;}

				    }

					
					if (!protagonistObj.collision.south)
					{overallDisplacement.y -= protagonistObj.speed ;}
					



				}


                
				if ((e.key === "a" || e.key === "A") && protagonistObj.cutSceneAnimation == false) {

					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "west")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

						    //overallDisplacement.x += protagonistObj.speed ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "west" ;
					    protagonistObj.currentVerticalFrameIndex = 1 ;
					}			



 
                    for (var i = 0; i < dungeonPillarsCount; i++) {
					
					
					    if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonPillars[i].y+50+overallDisplacement.y    &&   
						        protagonistObj.y+protagonistObj.actualHeight/2>dungeonPillars[i].y-50+overallDisplacement.y)    ||  
						        (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonPillars[i].y+50+overallDisplacement.y    &&   
						        protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonPillars[i].y-50+overallDisplacement.y)  )    &&

				    	        (protagonistObj.x-protagonistObj.actualWidth/2 == dungeonPillars[i].x+50+overallDisplacement.x)   )  

						        {protagonistObj.collision.west = true;
						        break;}

					    else 	

						    {protagonistObj.collision.west = false;}
					  
				    }
					  
				



				    if (!protagonistObj.collision.west) {

                        for (var i = 0; i < dungeonWallsCount; i++) {
					
					
					        if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonWalls[i].y+50+overallDisplacement.y    &&   
						            protagonistObj.y+protagonistObj.actualHeight/2>dungeonWalls[i].y-50+overallDisplacement.y)    ||  
						            (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonWalls[i].y+50+overallDisplacement.y    &&   
						            protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonWalls[i].y-50+overallDisplacement.y)  )    &&

				    	            (protagonistObj.x-protagonistObj.actualWidth/2 == dungeonWalls[i].x+50+overallDisplacement.x)   )  

						            {protagonistObj.collision.west = true;
						            break;}

					        else 	

						        {protagonistObj.collision.west = false;}
					  
				        }

				        if (protagonistObj.x-protagonistObj.actualWidth/2 == dungeonLeftBoundary+overallDisplacement.x) 
				        {protagonistObj.collision.west = true;}

				    }
                    




					if (!protagonistObj.collision.west)
					{overallDisplacement.x += protagonistObj.speed ;}
				}


                
				if ((e.key === "d" || e.key === "D") && protagonistObj.cutSceneAnimation == false) {

					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "east")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;
  
						    //overallDisplacement.x -= protagonistObj.speed ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "east" ;
					    protagonistObj.currentVerticalFrameIndex = 2 ;
					}		





                for (var i = 0; i < dungeonPillarsCount; i++) {
					
					
					    if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonPillars[i].y+50+overallDisplacement.y    &&   
						        protagonistObj.y+protagonistObj.actualHeight/2>dungeonPillars[i].y-50+overallDisplacement.y)    ||  
						        (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonPillars[i].y+50+overallDisplacement.y    &&   
						        protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonPillars[i].y-50+overallDisplacement.y)  )    &&

				    	        (protagonistObj.x+protagonistObj.actualWidth/2 == dungeonPillars[i].x-50+overallDisplacement.x)   )  

						        {protagonistObj.collision.east = true;
						        break;}

					    else 	

						    {protagonistObj.collision.east = false;}
					  
				    }
					  
				



				    if (!protagonistObj.collision.east) {

                        for (var i = 0; i < dungeonWallsCount; i++) {
					
					
					        if (  ( (protagonistObj.y+protagonistObj.actualHeight/2<dungeonWalls[i].y+50+overallDisplacement.y    &&   
						            protagonistObj.y+protagonistObj.actualHeight/2>dungeonWalls[i].y-50+overallDisplacement.y)    ||  
						            (protagonistObj.y+protagonistObj.actualHeight/2-20<dungeonWalls[i].y+50+overallDisplacement.y    &&   
						            protagonistObj.y+protagonistObj.actualHeight/2-20>dungeonWalls[i].y-50+overallDisplacement.y)  )    &&

				    	            (protagonistObj.x+protagonistObj.actualWidth/2 == dungeonWalls[i].x-50+overallDisplacement.x)   )  

						            {protagonistObj.collision.east = true;
						            break;}

					        else 	

						        {protagonistObj.collision.east = false;}
					  
				        }

				        if (protagonistObj.x+protagonistObj.actualWidth/2 == dungeonRightBoundary+overallDisplacement.x) 
				        {protagonistObj.collision.east = true;}

				    }





					if (!protagonistObj.collision.east)
					{overallDisplacement.x -= protagonistObj.speed ;}
				}


                
				if ((e.key === "w" || e.key === "W") && protagonistObj.cutSceneAnimation == false) {

					if (!(protagonistObj.movementAnimationStarted == true && protagonistObj.direction == "north")) {

						clearInterval(protagonistObj.movementAnimationTimeInterval) ;
					
					    protagonistObj.movementAnimationTimeInterval = setInterval ( function () {

						    if (protagonistObj.currentHorizontalFrameIndex == protagonistObj.totalAnimationFrames -1 ) {
							protagonistObj.currentHorizontalFrameIndex = 1 ;
						    } else { protagonistObj.currentHorizontalFrameIndex++ ; }

					        protagonistObj.footStepsSoundFile.play() ;

						    //overallDisplacement.y += protagonistObj.speed ;

					    } , 100 ) ;

					    protagonistObj.movementAnimationStarted = true ;
					    protagonistObj.direction = "north" ;
					    protagonistObj.currentVerticalFrameIndex = 3 ;

					}		




                    for (var i = 0; i < dungeonPillarsCount; i++) {
					
					
					    if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
						        protagonistObj.x+protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)    ||  
						        (protagonistObj.x-protagonistObj.actualWidth/2<dungeonPillars[i].x+50+overallDisplacement.x    &&   
						        protagonistObj.x-protagonistObj.actualWidth/2>dungeonPillars[i].x-50+overallDisplacement.x)  )    &&

				    	        (protagonistObj.y+protagonistObj.actualHeight/2-20 == dungeonPillars[i].y+50+overallDisplacement.y)   )  

						        {protagonistObj.collision.north = true;
						        break;}

					    else 	

						    {protagonistObj.collision.north = false;}
					  
				    }
					  
				



				    if (!protagonistObj.collision.north) {

                        for (var i = 0; i < dungeonWallsCount; i++) {
					
				            if (  ( (protagonistObj.x+protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
						            protagonistObj.x+protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)    ||  
						            (protagonistObj.x-protagonistObj.actualWidth/2<dungeonWalls[i].x+50+overallDisplacement.x    &&   
						            protagonistObj.x-protagonistObj.actualWidth/2>dungeonWalls[i].x-50+overallDisplacement.x)  )    &&

				    	            (protagonistObj.y+protagonistObj.actualHeight/2-20 == dungeonWalls[i].y+50+overallDisplacement.y)   )  

						            {protagonistObj.collision.north = true;
						            break;}

					        else 	

						        {protagonistObj.collision.north = false;}

				        }

				        if (protagonistObj.y+protagonistObj.actualHeight/2-20 == dungeonTopBoundary+overallDisplacement.y) 
				        {protagonistObj.collision.north = true;}

				    }





					if (!protagonistObj.collision.north)
					{overallDisplacement.y += protagonistObj.speed ;}
				}



			} ) ; // event listner for keydown ends here



			document.addEventListener("keyup" , function () {

				clearInterval(protagonistObj.movementAnimationTimeInterval) ;
				protagonistObj.currentHorizontalFrameIndex = 0 ;
				protagonistObj.movementAnimationStarted = false ;
				protagonistObj.footStepsSoundFile.pause() ;
				protagonistObj.footStepsSoundFile.load() ;

			} ) ; 



			this.draw = function () {

				if (!protagonistObj.levelCompleted) {



				this.cxt.clearRect(0,0,canvas.width,canvas.height) ;

			    this.cxt.drawImage(dungeonBasicLayout,protagonistObj.x-150+overallDisplacement.x , 
			    	                                  protagonistObj.y-150+overallDisplacement.y ) ;

			    if (mainBossDoorKey.visible) 
			    {this.cxt.drawImage( mainBossDoorKeyImage , mainBossDoorKey.x-50+overallDisplacement.x , mainBossDoorKey.y-50+overallDisplacement.y ) ; }

				for (var i = 0; i < coinsCount ; i++) {

					this.cxt.drawImage( coinRotationSprite , coins[i].frameWidth*coins[i].currentFrameIndex , 0 , 
						                coins[i].frameWidth , coins[i].frameHeight , coins[i].x - coins[i].frameWidth/2+overallDisplacement.x , 
				                        coins[i].y - coins[i].frameHeight/2+overallDisplacement.y , coins[i].frameWidth , coins[i].frameHeight ) ;					
				}


			    for (var i = 0; i < dungeonWallsCount ; i++) {

					if (dungeonWalls[i].shadowed) {

						this.cxt.drawImage(wallWithShadow , dungeonWalls[i].x-50+overallDisplacement.x , 
							               dungeonWalls[i].y-50+overallDisplacement.y ) ;
					}					
				}


				for (var i = 0; i < dungeonWallsCount ; i++) {

					if (!dungeonWalls[i].shadowed) {

						this.cxt.drawImage(wallWithoutShadow , dungeonWalls[i].x-50+overallDisplacement.x , 
							               dungeonWalls[i].y-50+overallDisplacement.y ) ;
					}					
				}

				for (var i = 0; i < dungeonPillarsCount ; i++) {

					if (!dungeonPillars[i].shadowed) {

						this.cxt.drawImage(wallWithoutShadow , dungeonPillars[i].x-50+overallDisplacement.x , 
							               dungeonPillars[i].y-50+overallDisplacement.y ) ;
					}					
				}

				for (var i = 0; i < dungeonUpperBoundaryWallsToBeUnshadowedCount ; i++) {

					this.cxt.drawImage(wallWithoutShadow,dungeonUpperBoundaryWallsToBeUnshadowed[i].x-50+overallDisplacement.x , 
						                                 dungeonUpperBoundaryWallsToBeUnshadowed[i].y-50+overallDisplacement.y) ;		                              					
				}

				if (mainBossDoorKey.collected == true) {
				this.cxt.drawImage( mainBossDoorSprite , mainBossDoor.frameWidth*mainBossDoor.currentFrameIndex , 0 , 
					                mainBossDoor.frameWidth , mainBossDoor.frameHeight , 
					                mainBossDoor.x - mainBossDoor.frameWidth/2+overallDisplacement.x , 
					                mainBossDoor.y - mainBossDoor.frameHeight/2+overallDisplacement.y , 
					                mainBossDoor.frameWidth , mainBossDoor.frameHeight ) ;
			    }

			    for (var i = 0; i < dungeonNewFloorTilesCount ; i++) {

					this.cxt.drawImage(dungeonFloorTileImage , dungeonNewFloorTiles[i].x-50+overallDisplacement.x , 
						                                  dungeonNewFloorTiles[i].y-50+overallDisplacement.y) ;
					
				}

			    this.cxt.drawImage( protagonistImage , protagonistObj.frameWidth*protagonistObj.currentHorizontalFrameIndex , 
				                    protagonistObj.frameHeight*protagonistObj.currentVerticalFrameIndex , protagonistObj.frameWidth , 
				                    protagonistObj.frameHeight , protagonistObj.x - protagonistObj.frameWidth/2 , 
				                    protagonistObj.y - protagonistObj.frameHeight/2 , protagonistObj.frameWidth , protagonistObj.frameHeight ) ;


			    if (protagonistObj.visionRadius){
			    	addDungeonVision() ;
			    }


			    if (drawAimImage) {
				this.cxt.drawImage( aimImage , aim.x-aim.frameWidth/2 , aim.y-aim.frameHeight/2 ) ;
			    }




				}

				else{

					protagonistObj.cutSceneAnimationRadius = 5 ;
					protagonistObj.cutSceneAnimation = true ;
					

		            protagonistObj.cutSceneAnimationTimeInterval = setInterval ( function () {

		            	cxt.lineWidth = 10 ;
		                cxt.strokeStyle = "black" ;

		    	        cxt.beginPath() ;
		    	        cxt.arc(protagonistObj.x,protagonistObj.y,protagonistObj.cutSceneAnimationRadius,0,2*Math.PI) ;
		    	        cxt.stroke() ;

		    	        protagonistObj.cutSceneAnimationRadius += 9 ;

		    	        if (protagonistObj.cutSceneAnimationRadius >= 850) {
		    	 	        cxt.clearRect(0,0,canvas.width,canvas.height) ;
		    	 	        protagonistObj.stopRequestingFrame = true ;
		    	 	        clearInterval(protagonistObj.coinRotationAnimationTimeInterval) ;
		    	            clearInterval(protagonistObj.cutSceneAnimationTimeInterval) ;
		    	        }

		            } , 30 ) ;

				}



			}

			


			this.update = function () {


				for (var i = 0; i < coinsCount ; i++) {

					if (protagonistObj.x>coins[i].x-40+overallDisplacement.x && protagonistObj.x<coins[i].x+40+overallDisplacement.x &&
						protagonistObj.y+protagonistObj.actualHeight/2>coins[i].y-20+overallDisplacement.y && 
						protagonistObj.y+protagonistObj.actualHeight/2<coins[i].y+50+overallDisplacement.y) 

						{ protagonistObj.coinsCollected ++ ;
						  coins.splice(i,1) ;
						  coinsCount -- ;
						  console.log("coins collected : " + protagonistObj.coinsCollected) ;

						  protagonistObj.coinCollectionSoundFile.pause();
						  protagonistObj.coinCollectionSoundFile.load();
						  protagonistObj.coinCollectionSoundFile.play();

						  break; }
					
				}

                
                if (!mainBossDoorKey.collected)
				if (protagonistObj.x>mainBossDoorKey.x-50+overallDisplacement.x && protagonistObj.x<mainBossDoorKey.x+50+overallDisplacement.x &&
					protagonistObj.y>mainBossDoorKey.y-50+overallDisplacement.y && 
					protagonistObj.y<mainBossDoorKey.y+50+overallDisplacement.y) 

					{ protagonistObj.mainBossDoorKeyCollectionSoundFile.play();
					  mainBossDoorKey.collected = true ;

					  for (var randPillarIndex ; ; ) {

					  	randPillarIndex = Math.floor(100*Math.random()/(100/dungeonPillarsCount)) ;

					  	if (dungeonPillars[randPillarIndex].shadowed) {
					  		mainBossDoor = new door(dungeonPillars[randPillarIndex].x , dungeonPillars[randPillarIndex].y+25) ;
					  		break;
					  	}else{
					  		if (dungeonWalls[randPillarIndex].shadowed) {
					  			mainBossDoor = new door(dungeonWalls[randPillarIndex].x , dungeonWalls[randPillarIndex].y+25) ;
					  			break;
					  		}else{continue;}
					  	}
					  
					  }

				    }


				if (!mainBossDoorKey.collected) {

					protagonistObj.mainBossDoorKeyClueSoundFile.volume = (50/Math.sqrt(Math.pow(protagonistObj.x-(mainBossDoorKey.x + 
						overallDisplacement.x),2) + Math.pow(protagonistObj.y-(mainBossDoorKey.y + overallDisplacement.y),2))) ;

					protagonistObj.mainBossDoorKeyClueSoundFile.play() ;
				}
				else{protagonistObj.mainBossDoorKeyClueSoundFile.pause() ;
					protagonistObj.mainBossDoorKeyClueSoundFile.load() ;}   





			} // end of update
      








		}// end of Game Constructor





		function initializeNewLevel () {


		mainBossDoorKey = undefined ;
		mainBossDoor = undefined ;  



		dungeonPillars = [] ;
		dungeonPillarsCount = 0 ;

		dungeonPillarsByDefault = [] ;     // i introduced this for the sake of removing pillars
		dungeonPillarsByDefaultCount = 0 ; // if pillars are not removed this is no diff from dungeonPillars


		dungeonNewFloorTiles = [] ;
		dungeonNewFloorTilesCount = 0 ;
		

		dungeonWalls = [] ;
		dungeonWallsCount = 0 ;

        dungeonUpperBoundaryWallsToBeUnshadowed = [] ;
        dungeonUpperBoundaryWallsToBeUnshadowedCount = 0 ;


		coins = [] ;
		coinsCount = 0 ;


		// remember camera is fixed to the protagonist, so the entire surrounding moves, so is the overallDisplacement object
		overallDisplacement = { x:0 , y:0 } ;

		// our game's protagonist
		protagonistObj = new protagonist() ;







		for (var i = 0 ; i < 7 ; i++) {
			for (var j = 0 ; j < 12 ; j++) {

				dungeonPillars[dungeonPillarsCount] = new pillar( protagonistObj.x+100+j*200 , protagonistObj.y+100+i*200 ) ;
				dungeonPillarsCount++ ;

				dungeonPillarsByDefault[dungeonPillarsByDefaultCount] = new pillar( protagonistObj.x+100+j*200 , protagonistObj.y+100+i*200 ) ;
				dungeonPillarsByDefaultCount++ ;
				
			}
			
		}


        /*

        // im removing few pillars 
        // just removing is not sufficient, i need to change the shadowed property of appropriate walls and pillars

		for (var rowNo = 0; rowNo < 7 ; rowNo++) {

			rand = Math.floor(100*Math.random()/(100/12)) ;

			dungeonNewFloorTiles[rowNo] = new dungeonFloorTile(dungeonPillars[rowNo*11 + rand].x , dungeonPillars[rowNo*11 + rand].y) ; 

			dungeonNewFloorTilesCount ++ ;

			dungeonPillars.splice(rowNo*11 + rand,1) ;
			dungeonPillarsCount -- ;
			
		}*/

        

        //when the 1st row pillars have nothern walls, corresponding boundary walls should unshadowed as the basic layout has all upper boundary walls shadowed by default.


		for (var i = 0 , rand ; i < dungeonPillarsCount ; i++) {

            // as said earlier each pillar has a wall and it can be in either of 4 directions which is randomly generated
            rand = Math.floor(100*Math.random()/25) ; // 0 -> east , 1 -> south , 2 -> west , 3 -> north . 
            
            
            // avoiding horizontally consectutive walls with similar type to create more crooked maze
            // && (rand == 0 || rand == 2) include this along with i>0 condition to avoid formation of long continuous horizontal walls alone
            if (i>0) {
            	if(dungeonWalls[dungeonWallsCount-1].type == rand) 
            		{rand = Math.floor(100*Math.random()/25) ;}//{i--; continue;}//
            }

            // avoiding vertically consectutive walls with similar type to create more crooked maze
            // && (rand == 1 || rand == 3) include this along with i>11 condition to avoid formation of long continuous vertical walls alone
            if (i>11) {
            	if (dungeonWalls[dungeonWallsCount-12].type == rand) 
            		{rand = Math.floor(100*Math.random()/25) ;}//{i--; continue;}//
            }
            




            // avoiding formation of closed boxes/rooms formed by 4 adjacent pillars like this ::
            if (i>12) {
            	// anticlockwise orientation of walls to form a room/box
            	if (dungeonWalls[dungeonWallsCount-1].type == 0 && dungeonWalls[dungeonWallsCount-12].type == 2 
            	                         && dungeonWalls[dungeonWallsCount-13].type == 1) {
            	    if (rand == 3) {i--; continue;}
                }

                // clockwise orientation of walls to form a room/box
                if (dungeonWalls[dungeonWallsCount-1].type == 3 && dungeonWalls[dungeonWallsCount-12].type == 1 
            	                         && dungeonWalls[dungeonWallsCount-13].type == 0) {
            	    if (rand == 2) {i--; continue;}
                }
            }


            	

			if (rand == 0) {

				dungeonWalls[dungeonWallsCount] = new wall (dungeonPillars[i].x+100 , dungeonPillars[i].y) ;
			    dungeonWalls[dungeonWallsCount].shadowed = true ;
			    // eastern and western walls are always shadowed and do not affect other pillar's shadowed property

			} else { if (rand == 2) {

				    // avoiding overlapping of present pillar's western wall to the horizontally preceeding pillar's eastern wall
				    if ( i>0 && dungeonWalls[dungeonWallsCount-1].x == dungeonPillars[i].x-100 ) 
				        {i--; continue;}

					dungeonWalls[dungeonWallsCount] = new wall (dungeonPillars[i].x-100 , dungeonPillars[i].y) ;
				    dungeonWalls[dungeonWallsCount].shadowed = true ;
				    // eastern and western walls are always shadowed and do not affect other pillar's shadowed property

				} else { if (rand == 1) {

					    dungeonWalls[dungeonWallsCount] = new wall (dungeonPillars[i].x , dungeonPillars[i].y+100) ;
					    dungeonWalls[dungeonWallsCount].shadowed = false ;
					    dungeonPillars[i].shadowed = false ;
					    // nothern and southern walls are always not shadowed coz they always lie in between 2 adjacent pillars
					    // southern wall affects it's pillar's shadowed property, coz the wall becomes exposed before it's pillar

				    }

				}
			}

			if (rand == 3) {
				if (i > 11) {

					// avoiding overlapping of present pillar's northern wall to the vertically preceeding pillar's southern wall
					if ( dungeonWalls[dungeonWallsCount-12].y == dungeonPillars[i].y-100 ) 
					 {i--; continue;}


					dungeonWalls[dungeonWallsCount] = new wall(dungeonPillars[i].x , dungeonPillars[i].y-100) ;
					dungeonWalls[dungeonWallsCount].shadowed = false ;
				    dungeonPillars[i-12].shadowed = false ;
				    // nothern and southern walls are always not shadowed coz they always lie in between 2 adjacent pillars
					// nothern wall affects vertically preceeding pillar's shadowed property, coz the wall removes that pillar's exposure

				} else { // 1st row pillars

					    dungeonWalls[dungeonWallsCount] = new wall(dungeonPillars[i].x , dungeonPillars[i].y-100) ;
					    dungeonWalls[dungeonWallsCount].shadowed = false ;

					    dungeonUpperBoundaryWallsToBeUnshadowed[dungeonUpperBoundaryWallsToBeUnshadowedCount]    =    
					                                    new dungeonUpperBoundaryWall(dungeonPillars[i].x , dungeonPillars[i].y-200) ;

					    dungeonUpperBoundaryWallsToBeUnshadowedCount++ ;
					    // nothern walls of the pillars from the 1st row affect the dungeon's corresponding upper boundary walls

				}
			    


			}

			dungeonWalls[dungeonWallsCount].type = rand ;

			dungeonWallsCount++ ;			
		}



		// randPillarIndex -> 3 to 83
		for (var randPillarIndex = Math.floor(100*Math.random()/(100/81)) + 3 , rand ; ; randPillarIndex = Math.floor(100*Math.random()/(100/81)) + 3 ) 
		{
			if (randPillarIndex == (12 || 13 || 14 || 24 || 25 || 26)) {continue;}

			// so the key wont be anywhere near the pillars with index 0,1,2,12,13,14,24,25,26

			rand = Math.floor(100*Math.random()/50) ;

		    // 0 -> south-east , 1 -> north-east


			if (rand == 0) {

				mainBossDoorKey = new doorKey(dungeonPillarsByDefault[randPillarIndex].x+100 , 
				                              dungeonPillarsByDefault[randPillarIndex].y+100) ; 
		    }

			if (rand == 1) {

				mainBossDoorKey = new doorKey(dungeonPillarsByDefault[randPillarIndex].x+100 , 
				                              dungeonPillarsByDefault[randPillarIndex].y-100) ; 
		    }

			break ;
			
		}

       


        // generating coins like how we did for walls
		for (var i = 0 , rand ; i < dungeonPillarsByDefaultCount ; i++) {


            // each pillar has a coin , it can be in either of the 4 directions (can also be inside the wall)
            // or be inside the pillar ...... do this in the later stages
            rand = Math.floor(100*Math.random()/25) ; // 0 -> east , 1 -> south , 2 -> west , 3 -> north 
            // 4 -> inside the pillar ..... do this in the later stages , u need to add visibility of coin as pillars are part of basic layout
            
            
                      	
			if (rand == 0) {

				coins[coinsCount] = new coin (dungeonPillarsByDefault[i].x+100 , dungeonPillarsByDefault[i].y) ;

			} else { if (rand == 2) {

				    // avoiding overlapping of present pillar's western coin to the horizontally preceeding pillar's eastern coin
				    if ( i>0 && coins[coinsCount-1].x == dungeonPillarsByDefault[i].x-100 ) 
				        {i--; continue;}

					coins[coinsCount] = new coin (dungeonPillarsByDefault[i].x-100 , dungeonPillarsByDefault[i].y) ;

				} else { if (rand == 1) {

					    coins[coinsCount] = new coin (dungeonPillarsByDefault[i].x , dungeonPillarsByDefault[i].y+100) ;

				    }

				}
			}

			if (rand == 3) {
				if (i > 11) {

					// avoiding overlapping of present pillar's northern coin to the vertically preceeding pillar's southern coin
					if ( coins[coinsCount-12].y == dungeonPillarsByDefault[i].y-100 ) 
					 {i--; continue;}

				} 
				coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x , dungeonPillarsByDefault[i].y-100) ;	    
			}

			//if (rand == 4) {coins[coinsCount] = new coin (dungeonPillars[i].x , dungeonPillars[i].y) ;}
            


			coinsCount++ ;

						
		}        


		

		// now this is the second step of coin generation , in the first step coins are generated only vertically and horizontally but not diagonally
		for (var i = 0 , rand ; i < dungeonPillarsByDefaultCount ; i++) {


            rand = Math.floor(100*Math.random()/50) ; // 0 -> north-east , 1 -> south-west
            
            

			if (rand == 0) {
				if (i > 11) {

					// avoiding overlapping of present pillar's north-eastern coin to the vertically preceeding pillar's horizontally succeeding pillar's south-western coin
					if ((coins[coinsCount-12+1].y == dungeonPillarsByDefault[i].y-100) && (coins[coinsCount-12+1].x == dungeonPillarsByDefault[i].x+100)) 
					    {coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x-100 , dungeonPillarsByDefault[i].y+100) ;}//south-western coin
					else 
						{coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x+100 , dungeonPillarsByDefault[i].y-100) ;}// north-eastern coin

				}else {coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x+100 , dungeonPillarsByDefault[i].y-100) ;}// north-eastern coin
					    
			}

			if (rand == 1) {coins[coinsCount] = new coin(dungeonPillarsByDefault[i].x-100 , dungeonPillarsByDefault[i].y+100) ;}


			coinsCount++ ;

						
		}


		





		// should draw the image only after it is loaded

		if (drawEverything && level == 1) {

			drawInitialFrame() ;

		}





			protagonistObj.coinRotationAnimationTimeInterval = setInterval(function () {

						    for (var i = 0; i < coinsCount; i++) {

						    	if (coins[i].currentFrameIndex == coins[i].totalAnimationFrames -1 ) {
							        coins[i].currentFrameIndex = 0 ;
						            } else { coins[i].currentFrameIndex++ ; }						    	
						    }

					    },70) ;



			protagonistObj.cutSceneAnimationTimeInterval = setInterval( function () {
				cxt.lineWidth = 20 ;
				cxt.strokeStyle = "black" ;


				cxt.clearRect(0,0,canvas.width,canvas.height) ;

				drawInitialFrame() ;

				for (var i = protagonistObj.cutSceneAnimationRadius ; i <= 850 ; i += 19 ) {				
				    cxt.beginPath();
				    cxt.arc(760,370,i,0,2*Math.PI) ;
				    cxt.stroke() ;	
				}

				if (protagonistObj.cutSceneAnimationRadius >= 850) {
					protagonistObj.cutSceneAnimationRadius = 10 ;
					protagonistObj.cutSceneAnimation = false ;
					clearInterval(protagonistObj.cutSceneAnimationTimeInterval) ;
				}else{protagonistObj.cutSceneAnimationRadius += 19 ;}

			} , 50 ) ;



			



		} // end of initializeNewLevel






		function drawInitialFrame () {

			// drawing the basic dungeon layout
			cxt.drawImage(dungeonBasicLayout,protagonistObj.x-150,protagonistObj.y-150) ;

			if (drawMainBossDoorKeyImage && mainBossDoorKey.visible == true) {
				cxt.drawImage( mainBossDoorKeyImage , mainBossDoorKey.x-50 , mainBossDoorKey.y-50 ) ;
			}         	

			if(drawCoinRotationSprite) {

				for (var i = 0; i < coinsCount ; i++) {

					cxt.drawImage( coinRotationSprite , coins[i].frameWidth*coins[i].currentFrameIndex , 
				                   0 , coins[i].frameWidth , coins[i].frameHeight , coins[i].x - coins[i].frameWidth/2 , 
				                   coins[i].y - coins[i].frameHeight/2 , coins[i].frameWidth , coins[i].frameHeight ) ;					
				}

			}


			if (drawWallWithShadow) {

				// drawing walls with shadow
				for (var i = 0; i < dungeonWallsCount ; i++) {

					if (dungeonWalls[i].shadowed) {

						cxt.drawImage(wallWithShadow,dungeonWalls[i].x-50,dungeonWalls[i].y-50) ;
					}					
				}
			}

			if (drawWallWithoutShadow) {

				// drawing walls with no shadow
				for (var i = 0; i < dungeonWallsCount ; i++) {

					if (!dungeonWalls[i].shadowed) {

						cxt.drawImage(wallWithoutShadow,dungeonWalls[i].x-50,dungeonWalls[i].y-50) ;
					}					
				}

				// updating the pillars with no shadow
				for (var i = 0; i < dungeonPillarsCount ; i++) {

					if (!dungeonPillars[i].shadowed) {

						cxt.drawImage(wallWithoutShadow,dungeonPillars[i].x-50,dungeonPillars[i].y-50) ;
					}					
				}

				// updating the dungeon's upper boundary walls with no shadow
				for (var i = 0; i < dungeonUpperBoundaryWallsToBeUnshadowedCount ; i++) {

					cxt.drawImage(wallWithoutShadow,dungeonUpperBoundaryWallsToBeUnshadowed[i].x-50 , 
						                            dungeonUpperBoundaryWallsToBeUnshadowed[i].y-50) ;		                              					
				}

			}

			if (drawDungeonfloorTile) {

				for (var i = 0; i < dungeonNewFloorTilesCount ; i++) {

					cxt.drawImage(dungeonFloorTileImage,dungeonNewFloorTiles[i].x-50,dungeonNewFloorTiles[i].y-50) ;
					
				}
			}

			// drawing the protagonist
			if (drawProtagonist) {
				cxt.drawImage( protagonistImage , protagonistObj.frameWidth*protagonistObj.currentHorizontalFrameIndex , 
				               protagonistObj.frameHeight*protagonistObj.currentVerticalFrameIndex , protagonistObj.frameWidth , 
				               protagonistObj.frameHeight , protagonistObj.x - protagonistObj.frameWidth/2 , 
				               protagonistObj.y - protagonistObj.frameHeight/2 , protagonistObj.frameWidth , protagonistObj.frameHeight ) ;
			}


			if(protagonistObj.visionRadius){
				addDungeonVision() 
			};

			if (drawAimImage) {
				cxt.drawImage( aimImage , aim.x-aim.frameWidth/2 , aim.y-aim.frameHeight/2 ) ;
			}

			 

		}




		function addDungeonVision () {

			cxt.lineWidth = 30 ;

			for (var i = 50 ; i <= protagonistObj.visionRadius ; i += 15) {

			 cxt.strokeStyle = "rgba(0,0,0," + i/protagonistObj.visionRadius + ")" ;

			    cxt.beginPath() ;
		    	cxt.arc(protagonistObj.x,protagonistObj.y,i,0,2*Math.PI) ;
		    	cxt.stroke() ;
			    	
			}

			cxt.lineWidth = (850 - protagonistObj.visionRadius) ;
			cxt.strokeStyle = "black" ;

			cxt.beginPath() ;
		    cxt.arc(protagonistObj.x,protagonistObj.y,protagonistObj.visionRadius + (850 - protagonistObj.visionRadius)/2 ,0,2*Math.PI) ;
		    cxt.stroke()
		}



		






		var game = new Game() ;



		

		function gameLoop() {

			if (!protagonistObj.cutSceneAnimation){
				game.update() ;			
			    game.draw() ;
			}
			
			if (!protagonistObj.stopRequestingFrame)
			{window.requestAnimationFrame(gameLoop) ;}
		    else{
		        cancelAnimationFrame(myVar);

		    	setTimeout ( function () {
		    		startNewLevel() ;
		    	} , 2000 );

		    }
		
		}


		var myVar ;


		function startNewLevel () {

			initializeNewLevel() ;
			    
			myVar = window.requestAnimationFrame(gameLoop) ;

			
		}

		 

		startNewLevel();


	</script>
</body>
</html>